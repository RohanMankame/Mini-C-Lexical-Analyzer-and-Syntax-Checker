# Mini-C-Lexical-Analyzer-and-Syntax-Checker
This project implements the lexical analysis (tokenizing) and syntax checking (parsing) phases of a compiler for a simplified C-like programming language, referred to as "Mini-C.". It demonstrates fundamental compiler design principles, including tokenization, recursive-descent parsing, and parse tree generation.

## Features

* **Lexical Analysis:** Scans Mini-C source code, identifies, and categorizes tokens such as keywords, identifiers, operators, numerical literals, and boolean literals. It handles whitespace and single-line comments (`//`).
* **Syntax Checking:** Parses the token stream generated by the lexer to verify if the code adheres to the defined grammar of Mini-C.
* **Recursive-Descent Parsing:** The parser is implemented using a recursive-descent approach, with dedicated methods for each grammatical production rule.
* **Parse Tree Generation:** Upon successful parsing, the program constructs an in-memory parse tree, which can then be used to reconstruct an indentation-updated version of the source code.
* **Error Reporting:** Provides detailed error messages for both lexical and syntax errors, indicating the line and column number of the error.
* **Comprehensive Test Cases:** Includes a set of test files (`.minc` examples) demonstrating both successful parsing of valid code and specific error conditions for invalid code.

## How it Works

The project is structured into several key Java classes:

* **`Lexer.java`**: This is the lexical analyzer. It reads the Mini-C source code character by character, groups them into lexemes, and assigns them a token type (e.g., `IDENT`, `NUM_LIT`, `SEMI`, `FUNC`). It handles basic error cases for malformed tokens.
* **`Parser.java`**: This is the syntax analyzer (parser). It consumes the token stream from the `Lexer` and attempts to match it against the Mini-C grammar using a set of recursive methods, each representing a non-terminal rule (e.g., `program()`, `fun_decl()`, `stmt()`). If the input matches the grammar, it builds a parse tree. If not, it throws an exception with a detailed error message.
* **`ParseTree.java`**: Defines the data structures that represent the abstract syntax tree (AST) or parse tree. This tree is constructed by the `Parser` and allows for structured representation and subsequent operations like pretty-printing the code.
* **`Compiler.java`**: Acts as the orchestrator. It initializes the `Parser` with the input source code and calls the main parsing method. It then handles the overall success/failure reporting and initiates the pretty-printing of the parse tree if parsing is successful.
* **`Program.java`**: Contains the `main` method, which is the entry point for the application. It sets up the file reader for the Mini-C source file and initiates the `Compiler`.
* **`ParserVal.java`**: A utility class used by the Lexer to hold the attribute (lexeme value) of the token being processed.

## Running the Program

To compile and run this Mini-C compiler front-end, follow these steps:

1.  **Navigate to the Source Directory:**
    Open your terminal or command prompt and navigate to the `src` directory where all your `.java` files (and `Lexer.flex` if you have it) are located.
    ```bash
    cd path/to/your/project/src
    ```

2.  **Generate Lexer (if `Lexer.flex` is present):**
    If you have the `Lexer.flex` file (the JFlex specification for the lexer), you first need to generate `Lexer.java` from it. You'll need the `jflex-1.6.1.jar` tool for this.
    ```bash
    java -jar jflex-1.6.1.jar Lexer.flex
    ```
    *Note: If `Lexer.java` is already provided and up-to-date, you can skip this step.*

3.  **Compile the Java Code:**
    Compile all the Java source files.
    ```bash
    javac *.java
    ```

4.  **Run the Program with a Test File:**
    Execute the `Program.java` class, providing the path to a Mini-C test file as a command-line argument.
    For example, to test with `fail_09.minc` (assuming it's in the same directory or you provide the full path):
    ```bash
    java Program "fail_09.minc"
    ```
    Replace `"fail_09.minc"` with the name or full path of any `.minc` test file you wish to run.
    The program will then output whether a syntax error was found and, if successful, display the indentation-updated source code.

## Example Test Files

The project includes several example Mini-C source files (`.minc` extension) to test different aspects of the lexer and parser. These are usually located in a `samples` or `tests` directory within the project.

* `succ_01.minc` - `succ_10.minc`: Examples of syntactically correct Mini-C code that should parse successfully.
* `fail_01.minc` - `fail_10.minc`: Examples of Mini-C code containing lexical or syntax errors, designed to trigger error messages.

## Author

Rohan Mankame
